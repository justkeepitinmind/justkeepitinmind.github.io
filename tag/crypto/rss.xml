<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>shizuku&#39;s home • Posts by &#34;crypto&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Mon, 12 Feb 2024 16:16:34 +0800</pubDate>
        <lastBuildDate>Mon, 12 Feb 2024 16:16:34 +0800</lastBuildDate>
        <category>crypto</category>
        <item>
            <guid isPermalink="true">http://example.com/2024/02/12/please-sign-in-HKCERT-CTF/</guid>
            <title>Sign_in_Please_HKCERT_CTF</title>
            <link>http://example.com/2024/02/12/please-sign-in-HKCERT-CTF/</link>
            <category>crypto</category>
            <pubDate>Mon, 12 Feb 2024 16:16:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;妄图尝试cryptohack网站的ctf题目，想要挑一道solve数最多的软柿子捏，结果发现根本没有软柿子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cryptohack.org/challenges/ctf-archive/&#34;&gt;Sign_in_Please&lt;/a&gt; 网站最下面那道&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;代码分析&#34;&gt;&lt;a href=&#34;#代码分析&#34; class=&#34;headerlink&#34; title=&#34;代码分析&#34;&gt;&lt;/a&gt;代码分析&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def permutate(payload:bytes, pbox):
    return bytes([payload[x] for x in pbox])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;
class Client:
    def __init__(self, password : bytes):
        self.password = password

    def spy(self, pbox, salt : bytes):
        assert len(set(pbox)) == 20
        assert len(salt) == 4
        password = self.password
        permutated_password = permutate(password + salt, pbox)

        hashed_password = hashlib.sha256(permutated_password).hexdigest()
        print(f&amp;#39;[hash] &amp;#123;hashed_password&amp;#125;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;spy&lt;/strong&gt; 接收一个含有20个不同索引的&lt;strong&gt;pbox&lt;/strong&gt;，和一个4byte的&lt;strong&gt;slat&lt;/strong&gt;，把&lt;strong&gt;salt&lt;/strong&gt;加入16byte的&lt;strong&gt;password&lt;/strong&gt;后面之后按照&lt;strong&gt;pbox&lt;/strong&gt;中的索引进行重排，预期&lt;strong&gt;pbox&lt;/strong&gt;是[0,20)的一个重排&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auth&lt;/strong&gt; 不好转空子，能不能绕过基本上就看能不能拿到通过&lt;strong&gt;spy&lt;/strong&gt;拿到&lt;strong&gt;password&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;思路分析&#34;&gt;&lt;a href=&#34;#思路分析&#34; class=&#34;headerlink&#34; title=&#34;思路分析&#34;&gt;&lt;/a&gt;思路分析&lt;/h2&gt;&lt;p&gt;如果没有&lt;strong&gt;len(set(pbox)) &amp;#x3D;&amp;#x3D; 20&lt;/strong&gt;的判断的话, 而只是一个简单的&lt;strong&gt;len(pbox) &amp;#x3D;&amp;#x3D; 20&lt;/strong&gt;，我们可以让&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;salt = b&amp;#39;aaaa&amp;#39;
pbox = [19]*18 + [i, i + 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样&lt;strong&gt;permutated_password&lt;/strong&gt;就变成了&lt;strong&gt;b’a’*18&lt;/strong&gt;+??，其中？是base64字符，有64种可能，那我们直接根据sha256的结果64*64的枚举就可以把&lt;strong&gt;password&lt;/strong&gt;的 &lt;strong&gt;i&lt;/strong&gt; 和&lt;strong&gt;i + 1&lt;/strong&gt;处的索引值确定，那其实复原&lt;strong&gt;password&lt;/strong&gt;就不难了。&lt;/p&gt;
&lt;p&gt;可惜没有如果。&lt;/p&gt;
&lt;p&gt;有一个比较好想的空子是预期的pbox是[0,20)的重排，&lt;strong&gt;pbox&lt;/strong&gt;中的值大于20的确会报out of boundary的错，但他可以小于0啊，因为python支持负索引，所有我们可以spy可以每次只拿10个字符出来hash&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;salt = b&amp;#39;aaaa&amp;#39;
pbox = [16, 17, 18, 19] + [-4, -3, -2, -1]
pbox = pbox + [idx + i for i in range(6)]
pbox = pbox + [idx + i - 20 for i in range(6)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这样子构造&lt;strong&gt;pbox&lt;/strong&gt;，得到的&lt;strong&gt;permutated_password&lt;/strong&gt;只有6个未知字符，我们当然可以尝试&lt;strong&gt;sha256&lt;/strong&gt;直接枚举，但是我们这样就总共有$64^6&amp;#x3D;2^{36}$种可能，而我们计算机枚举的上限一般在$2^{32}$左右，我们现在直接枚举行吗？如行，只要你有很多台性能很棒的计算机帮你算的话，你到这儿就已经差不多结束了。&lt;/p&gt;
&lt;p&gt;但显然，我是没有那么好的计算机的。&lt;/p&gt;
&lt;p&gt;我们现在先换个思路，假如&lt;strong&gt;spy&lt;/strong&gt;的次数没有限制的话我们可以怎么做。那样子的话其实可以逐byte检验&lt;strong&gt;pbox&lt;/strong&gt;的每个值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;salt = b&amp;quot;dcba&amp;quot;
pbox1 = list(range(20))
pbox2 = [-1] + list(range(1, 20)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较&lt;strong&gt;spy(pbox1, slat)&lt;strong&gt;和&lt;/strong&gt;spy(pbox2, slat)&lt;strong&gt;否相等就可以判断&lt;/strong&gt;password&lt;/strong&gt;的第一位是不是a, 把-1改成-2, -3, -4，还能确定第一位是不是b,c,d。这样逐byte一个一个检查就可以线性时间确定&lt;strong&gt;password&lt;/strong&gt;的值了&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;spy最多&lt;/strong&gt;只能由9次，能够确定&lt;strong&gt;password&lt;/strong&gt;的一位都够呛&lt;/p&gt;
&lt;p&gt;但只要我还知道一个&lt;strong&gt;password&lt;/strong&gt;的字符的话，那我上面枚举的办法就只需要枚举$2^{30}$种情况了，那我还是能接受的。&lt;/p&gt;
&lt;p&gt;我们可以先假设&lt;strong&gt;password&lt;/strong&gt;的第一位是a,b,c,d种的一个，然后用最多5次&lt;strong&gt;spy&lt;/strong&gt;把第一位找到。如果不在的话我们可以直接重新连接了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;# 猜测password中第一位字符
def guess_the_first_byte() -&amp;gt; bytes:
    salt = b&amp;quot;abcd&amp;quot;
    pbox = list(range(20))
    # print(pbox)
    hash_password = spy(pbox, salt)
    for i in range(-4, 0):
        print(f&amp;quot;now is guess &amp;#123;bytes[salt[i]]&amp;#125;&amp;quot;)
        pbox = [i] + list(range(1, 20))
        if spy(pbox, salt) == hash_password:
            return bytes([salt[i]])
    return b&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;cnt = 0
while True:
    cnt += 1
    print(f&amp;quot;第&amp;#123;cnt&amp;#125;次连接&amp;quot;)
    conn = remote(IP, PORT)
    # print(&amp;quot;conneted&amp;quot;)
    first_byte = guess_the_first_byte()
    if first_byte == b&amp;quot;&amp;quot;:
        conn.close()
        print(&amp;quot;failed to guess the first byte&amp;quot;)
        continue
    print(f&amp;quot;the first byte is &amp;#123;first_byte&amp;#125;.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为每一位有64种可能，我们连个16次大约就能出了，这还是可以接受的&lt;/p&gt;
&lt;p&gt;知道&lt;strong&gt;password&lt;/strong&gt;的第一位之后，我们可以按照上面的方法在大约10min左右的时间暴力枚举出&lt;strong&gt;password&lt;/strong&gt;的2~6位。这儿又需要&lt;strong&gt;spy&lt;/strong&gt;1次&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def brute(idx: int, first_byte):
    salt = b&amp;quot;aaaa&amp;quot;
    pbox = [0, 16, 17, 18, 19] + [-20, -4, -3, -2, -1]
    pbox = pbox + [idx + i for i in range(5)]
    pbox = pbox + [idx + i - 20 for i in range(5)]
    hash_text = spy(pbox, salt)
    suffix = first_byte + salt
    print(hash_text)
    for a1 in charset:
        print(a1, end=&amp;quot; &amp;quot;)
        for a2 in charset:
            for a3 in charset:
                for a4 in charset:
                    for a5 in charset:
                        m = bytes([a1, a2, a3, a4, a5])
                        text = suffix * 2 + m * 2
                        if hashlib.sha256(text).hexdigest() == hash_text:
                            print()
                            return m
    print(&amp;quot;No sollution found&amp;quot;)
    return b&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们可以继续5位5位地爆破，但5位效率还是太低了。因为我们现在又多知道了几位，所有我们现在可以四位四位爆破了，这儿需要&lt;strong&gt;spy&lt;/strong&gt;3次。&lt;/p&gt;
&lt;p&gt;知道&lt;strong&gt;password&lt;/strong&gt;之后，我们就很容易一次&lt;strong&gt;auth&lt;/strong&gt;出flag了。刚刚好$5 + 1 + 3 + 1 &amp;#x3D; 10$次&lt;/p&gt;
&lt;p&gt;下面是完整代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from pwn import *
import base64
import hashlib

charset = b&amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&amp;quot;

IP, PORT = &amp;quot;archive.cryptohack.org 1024&amp;quot;.split()


def spy(pbox: list, salt: bytes):
    conn.recvuntil(b&amp;quot;[cmd] &amp;quot;)
    conn.sendline(b&amp;quot;spy&amp;quot;)

    conn.recvuntil(b&amp;quot;[pbox] &amp;quot;)
    conn.sendline(str(pbox).encode())

    conn.recvuntil(b&amp;quot;[salt] &amp;quot;)
    conn.sendline(base64.b64encode(salt))

    conn.recvuntil(b&amp;quot;[hash] &amp;quot;)
    recv_text = conn.recvline()
    return recv_text.strip().decode()


def permutate(payload: bytes, pbox):
    return bytes([payload[x] for x in pbox])


def auth(password: bytes):
    conn.recvuntil(b&amp;quot;[cmd] &amp;quot;)
    conn.sendline(b&amp;quot;auth&amp;quot;)

    conn.recvuntil(b&amp;quot;[pbox] &amp;quot;)
    pbox = eval(conn.recvline().strip().decode())

    conn.recvuntil(b&amp;quot;[salt] &amp;quot;)
    salt = base64.b64decode(conn.recvline().strip())

    conn.recvuntil(b&amp;quot;[hash] &amp;quot;)
    permutated_password = permutate(password + salt, pbox)
    conn.sendline(hashlib.sha256(permutated_password).hexdigest().encode())

    return conn.recvline().strip()


# 爆破idx往后五位字符需要知道第一个字符
def brute(idx: int, first_byte):
    salt = b&amp;quot;aaaa&amp;quot;
    pbox = [0, 16, 17, 18, 19] + [-20, -4, -3, -2, -1]
    pbox = pbox + [idx + i for i in range(5)]
    pbox = pbox + [idx + i - 20 for i in range(5)]
    hash_text = spy(pbox, salt)
    suffix = first_byte + salt
    print(hash_text)
    for a1 in charset:
        print(a1, end=&amp;quot; &amp;quot;)
        for a2 in charset:
            for a3 in charset:
                for a4 in charset:
                    for a5 in charset:
                        m = bytes([a1, a2, a3, a4, a5])
                        text = suffix * 2 + m * 2
                        if hashlib.sha256(text).hexdigest() == hash_text:
                            print()
                            return m
    print(&amp;quot;No sollution found&amp;quot;)
    return b&amp;quot;&amp;quot;


def brute_four_bytes(idx: int, b1, b2):
    salt = b&amp;quot;aaaa&amp;quot;
    pbox = [0, 1, 16, 17, 18, 19] + [-20, -19, -4, -3, -2, -1]
    pbox = pbox + [idx + i for i in range(4)]
    pbox = pbox + [idx + i - 20 for i in range(4)]
    hash_text = spy(pbox, salt)
    suffix = b1 + b2 + salt
    print(hash_text)
    for a1 in charset:
        for a2 in charset:
            for a3 in charset:
                for a4 in charset:
                    m = bytes([a1, a2, a3, a4])
                    text = suffix * 2 + m * 2
                    if hashlib.sha256(text).hexdigest() == hash_text:
                        return m
    print(&amp;quot;No sollution found&amp;quot;)
    return b&amp;quot;&amp;quot;


# 猜测password中第一位字符
def guess_the_first_byte() -&amp;gt; bytes:
    salt = b&amp;quot;abcd&amp;quot;
    pbox = list(range(20))
    # print(pbox)
    hash_password = spy(pbox, salt)
    for i in range(-4, 0):
        print(f&amp;quot;now is guess &amp;#123;bytes[salt[i]]&amp;#125;&amp;quot;)
        pbox = [i] + list(range(1, 20))
        if spy(pbox, salt) == hash_password:
            return bytes([salt[i]])
    return b&amp;quot;&amp;quot;


cnt = 0
while True:
    cnt += 1
    print(f&amp;quot;第&amp;#123;cnt&amp;#125;次连接&amp;quot;)
    conn = remote(IP, PORT)
    # print(&amp;quot;conneted&amp;quot;)
    first_byte = guess_the_first_byte()
    if first_byte == b&amp;quot;&amp;quot;:
        conn.close()
        print(&amp;quot;failed to guess the first byte&amp;quot;)
        continue
    print(f&amp;quot;the first byte is &amp;#123;first_byte&amp;#125;.&amp;quot;)

    password = first_byte
    password += brute(1, first_byte)[:3]
    print(f&amp;quot;the prefix of password is &amp;#123;password&amp;#125;&amp;quot;)
    for i in range(4, 13, 4):
        password += brute_four_bytes(i, first_byte, bytes([password[1]]))
    print(password)

    print(auth(password))
    break
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
