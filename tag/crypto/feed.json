{
    "version": "https://jsonfeed.org/version/1",
    "title": "shizuku's home • All posts by \"crypto\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/02/12/please-sign-in-HKCERT-CTF/",
            "url": "http://example.com/2024/02/12/please-sign-in-HKCERT-CTF/",
            "title": "Sign_in_Please_HKCERT_CTF",
            "date_published": "2024-02-12T08:16:34.000Z",
            "content_html": "<p>妄图尝试cryptohack网站的ctf题目，想要挑一道solve数最多的软柿子捏，结果发现根本没有软柿子。</p>\n<p><a href=\"https://cryptohack.org/challenges/ctf-archive/\">Sign_in_Please</a> 网站最下面那道</p>\n<span id=\"more\"></span>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><pre><code class=\"python\">def permutate(payload:bytes, pbox):\n    return bytes([payload[x] for x in pbox])\n</code></pre>\n<pre><code class=\"python\">\nclass Client:\n    def __init__(self, password : bytes):\n        self.password = password\n\n    def spy(self, pbox, salt : bytes):\n        assert len(set(pbox)) == 20\n        assert len(salt) == 4\n        password = self.password\n        permutated_password = permutate(password + salt, pbox)\n\n        hashed_password = hashlib.sha256(permutated_password).hexdigest()\n        print(f&#39;[hash] &#123;hashed_password&#125;&#39;)\n</code></pre>\n<p><strong>spy</strong> 接收一个含有20个不同索引的<strong>pbox</strong>，和一个4byte的<strong>slat</strong>，把<strong>salt</strong>加入16byte的<strong>password</strong>后面之后按照<strong>pbox</strong>中的索引进行重排，预期<strong>pbox</strong>是[0,20)的一个重排</p>\n<p><strong>auth</strong> 不好转空子，能不能绕过基本上就看能不能拿到通过<strong>spy</strong>拿到<strong>password</strong></p>\n<h2 id=\"思路分析\"><a href=\"#思路分析\" class=\"headerlink\" title=\"思路分析\"></a>思路分析</h2><p>如果没有<strong>len(set(pbox)) &#x3D;&#x3D; 20</strong>的判断的话, 而只是一个简单的<strong>len(pbox) &#x3D;&#x3D; 20</strong>，我们可以让</p>\n<pre><code class=\"python\">salt = b&#39;aaaa&#39;\npbox = [19]*18 + [i, i + 1]\n</code></pre>\n<p>这样<strong>permutated_password</strong>就变成了<strong>b’a’*18</strong>+??，其中？是base64字符，有64种可能，那我们直接根据sha256的结果64*64的枚举就可以把<strong>password</strong>的 <strong>i</strong> 和<strong>i + 1</strong>处的索引值确定，那其实复原<strong>password</strong>就不难了。</p>\n<p>可惜没有如果。</p>\n<p>有一个比较好想的空子是预期的pbox是[0,20)的重排，<strong>pbox</strong>中的值大于20的确会报out of boundary的错，但他可以小于0啊，因为python支持负索引，所有我们可以spy可以每次只拿10个字符出来hash</p>\n<pre><code class=\"python\">salt = b&#39;aaaa&#39;\npbox = [16, 17, 18, 19] + [-4, -3, -2, -1]\npbox = pbox + [idx + i for i in range(6)]\npbox = pbox + [idx + i - 20 for i in range(6)]\n</code></pre>\n<p>通过这样子构造<strong>pbox</strong>，得到的<strong>permutated_password</strong>只有6个未知字符，我们当然可以尝试<strong>sha256</strong>直接枚举，但是我们这样就总共有$64^6&#x3D;2^{36}$种可能，而我们计算机枚举的上限一般在$2^{32}$左右，我们现在直接枚举行吗？如行，只要你有很多台性能很棒的计算机帮你算的话，你到这儿就已经差不多结束了。</p>\n<p>但显然，我是没有那么好的计算机的。</p>\n<p>我们现在先换个思路，假如<strong>spy</strong>的次数没有限制的话我们可以怎么做。那样子的话其实可以逐byte检验<strong>pbox</strong>的每个值</p>\n<pre><code class=\"python\">salt = b&quot;dcba&quot;\npbox1 = list(range(20))\npbox2 = [-1] + list(range(1, 20)) \n</code></pre>\n<p>比较<strong>spy(pbox1, slat)<strong>和</strong>spy(pbox2, slat)<strong>否相等就可以判断</strong>password</strong>的第一位是不是a, 把-1改成-2, -3, -4，还能确定第一位是不是b,c,d。这样逐byte一个一个检查就可以线性时间确定<strong>password</strong>的值了</p>\n<p>但<strong>spy最多</strong>只能由9次，能够确定<strong>password</strong>的一位都够呛</p>\n<p>但只要我还知道一个<strong>password</strong>的字符的话，那我上面枚举的办法就只需要枚举$2^{30}$种情况了，那我还是能接受的。</p>\n<p>我们可以先假设<strong>password</strong>的第一位是a,b,c,d种的一个，然后用最多5次<strong>spy</strong>把第一位找到。如果不在的话我们可以直接重新连接了。</p>\n<pre><code class=\"python\"># 猜测password中第一位字符\ndef guess_the_first_byte() -&gt; bytes:\n    salt = b&quot;abcd&quot;\n    pbox = list(range(20))\n    # print(pbox)\n    hash_password = spy(pbox, salt)\n    for i in range(-4, 0):\n        print(f&quot;now is guess &#123;bytes[salt[i]]&#125;&quot;)\n        pbox = [i] + list(range(1, 20))\n        if spy(pbox, salt) == hash_password:\n            return bytes([salt[i]])\n    return b&quot;&quot;\n</code></pre>\n<pre><code class=\"python\">cnt = 0\nwhile True:\n    cnt += 1\n    print(f&quot;第&#123;cnt&#125;次连接&quot;)\n    conn = remote(IP, PORT)\n    # print(&quot;conneted&quot;)\n    first_byte = guess_the_first_byte()\n    if first_byte == b&quot;&quot;:\n        conn.close()\n        print(&quot;failed to guess the first byte&quot;)\n        continue\n    print(f&quot;the first byte is &#123;first_byte&#125;.&quot;)\n</code></pre>\n<p>因为每一位有64种可能，我们连个16次大约就能出了，这还是可以接受的</p>\n<p>知道<strong>password</strong>的第一位之后，我们可以按照上面的方法在大约10min左右的时间暴力枚举出<strong>password</strong>的2~6位。这儿又需要<strong>spy</strong>1次</p>\n<pre><code class=\"python\">def brute(idx: int, first_byte):\n    salt = b&quot;aaaa&quot;\n    pbox = [0, 16, 17, 18, 19] + [-20, -4, -3, -2, -1]\n    pbox = pbox + [idx + i for i in range(5)]\n    pbox = pbox + [idx + i - 20 for i in range(5)]\n    hash_text = spy(pbox, salt)\n    suffix = first_byte + salt\n    print(hash_text)\n    for a1 in charset:\n        print(a1, end=&quot; &quot;)\n        for a2 in charset:\n            for a3 in charset:\n                for a4 in charset:\n                    for a5 in charset:\n                        m = bytes([a1, a2, a3, a4, a5])\n                        text = suffix * 2 + m * 2\n                        if hashlib.sha256(text).hexdigest() == hash_text:\n                            print()\n                            return m\n    print(&quot;No sollution found&quot;)\n    return b&quot;&quot;\n</code></pre>\n<p>接下来我们可以继续5位5位地爆破，但5位效率还是太低了。因为我们现在又多知道了几位，所有我们现在可以四位四位爆破了，这儿需要<strong>spy</strong>3次。</p>\n<p>知道<strong>password</strong>之后，我们就很容易一次<strong>auth</strong>出flag了。刚刚好$5 + 1 + 3 + 1 &#x3D; 10$次</p>\n<p>下面是完整代码</p>\n<pre><code class=\"python\">from pwn import *\nimport base64\nimport hashlib\n\ncharset = b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;\n\nIP, PORT = &quot;archive.cryptohack.org 1024&quot;.split()\n\n\ndef spy(pbox: list, salt: bytes):\n    conn.recvuntil(b&quot;[cmd] &quot;)\n    conn.sendline(b&quot;spy&quot;)\n\n    conn.recvuntil(b&quot;[pbox] &quot;)\n    conn.sendline(str(pbox).encode())\n\n    conn.recvuntil(b&quot;[salt] &quot;)\n    conn.sendline(base64.b64encode(salt))\n\n    conn.recvuntil(b&quot;[hash] &quot;)\n    recv_text = conn.recvline()\n    return recv_text.strip().decode()\n\n\ndef permutate(payload: bytes, pbox):\n    return bytes([payload[x] for x in pbox])\n\n\ndef auth(password: bytes):\n    conn.recvuntil(b&quot;[cmd] &quot;)\n    conn.sendline(b&quot;auth&quot;)\n\n    conn.recvuntil(b&quot;[pbox] &quot;)\n    pbox = eval(conn.recvline().strip().decode())\n\n    conn.recvuntil(b&quot;[salt] &quot;)\n    salt = base64.b64decode(conn.recvline().strip())\n\n    conn.recvuntil(b&quot;[hash] &quot;)\n    permutated_password = permutate(password + salt, pbox)\n    conn.sendline(hashlib.sha256(permutated_password).hexdigest().encode())\n\n    return conn.recvline().strip()\n\n\n# 爆破idx往后五位字符需要知道第一个字符\ndef brute(idx: int, first_byte):\n    salt = b&quot;aaaa&quot;\n    pbox = [0, 16, 17, 18, 19] + [-20, -4, -3, -2, -1]\n    pbox = pbox + [idx + i for i in range(5)]\n    pbox = pbox + [idx + i - 20 for i in range(5)]\n    hash_text = spy(pbox, salt)\n    suffix = first_byte + salt\n    print(hash_text)\n    for a1 in charset:\n        print(a1, end=&quot; &quot;)\n        for a2 in charset:\n            for a3 in charset:\n                for a4 in charset:\n                    for a5 in charset:\n                        m = bytes([a1, a2, a3, a4, a5])\n                        text = suffix * 2 + m * 2\n                        if hashlib.sha256(text).hexdigest() == hash_text:\n                            print()\n                            return m\n    print(&quot;No sollution found&quot;)\n    return b&quot;&quot;\n\n\ndef brute_four_bytes(idx: int, b1, b2):\n    salt = b&quot;aaaa&quot;\n    pbox = [0, 1, 16, 17, 18, 19] + [-20, -19, -4, -3, -2, -1]\n    pbox = pbox + [idx + i for i in range(4)]\n    pbox = pbox + [idx + i - 20 for i in range(4)]\n    hash_text = spy(pbox, salt)\n    suffix = b1 + b2 + salt\n    print(hash_text)\n    for a1 in charset:\n        for a2 in charset:\n            for a3 in charset:\n                for a4 in charset:\n                    m = bytes([a1, a2, a3, a4])\n                    text = suffix * 2 + m * 2\n                    if hashlib.sha256(text).hexdigest() == hash_text:\n                        return m\n    print(&quot;No sollution found&quot;)\n    return b&quot;&quot;\n\n\n# 猜测password中第一位字符\ndef guess_the_first_byte() -&gt; bytes:\n    salt = b&quot;abcd&quot;\n    pbox = list(range(20))\n    # print(pbox)\n    hash_password = spy(pbox, salt)\n    for i in range(-4, 0):\n        print(f&quot;now is guess &#123;bytes[salt[i]]&#125;&quot;)\n        pbox = [i] + list(range(1, 20))\n        if spy(pbox, salt) == hash_password:\n            return bytes([salt[i]])\n    return b&quot;&quot;\n\n\ncnt = 0\nwhile True:\n    cnt += 1\n    print(f&quot;第&#123;cnt&#125;次连接&quot;)\n    conn = remote(IP, PORT)\n    # print(&quot;conneted&quot;)\n    first_byte = guess_the_first_byte()\n    if first_byte == b&quot;&quot;:\n        conn.close()\n        print(&quot;failed to guess the first byte&quot;)\n        continue\n    print(f&quot;the first byte is &#123;first_byte&#125;.&quot;)\n\n    password = first_byte\n    password += brute(1, first_byte)[:3]\n    print(f&quot;the prefix of password is &#123;password&#125;&quot;)\n    for i in range(4, 13, 4):\n        password += brute_four_bytes(i, first_byte, bytes([password[1]]))\n    print(password)\n\n    print(auth(password))\n    break\n</code></pre>\n",
            "tags": [
                "crypto"
            ]
        }
    ]
}